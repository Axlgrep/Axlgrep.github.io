/*
 * 第六章:存储器层次结构
 *
 * 摘要: 随机访问存储器(Random-Access Memory, RAM)又分为静态随机存储器(SRAM, 也就是L1，L2, L3等
 *       高速缓存)和动态随机存储器(DRAM, 主存)
 *       只读存储器(Read-Only Memory, ROM)
 *       闪存(Flash Memory)
 *       从磁盘上读信息的时间在毫秒级，从DRAM读比从磁盘读快10w倍，从SRAM读比从磁盘读快100w倍
 *
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题6.1:
 *
 * 接下来，设r表示一个DRAM阵列中的行数，c表示列数，b(r)表示行寻址所需的位数，b(c)表示列寻址所需的位数,
 * 对于下面每个DRAM, 确定2的幂数的阵列维数，使得max(b(r), b(c))最小，max(b(r), b(c))是对阵列的行或者
 * 列寻址所需的位数中较大的值.
 *
 * 要使寻址所需位数最小，我们需要将数组组织成尽可能接近与正方形的样子
 * 16   -> 4  * 4
 * 128  -> 16 * 8
 * 512  -> 16 * 16
 * 1024 -> 32 * 16
 *
 * 组织     r     c     b(r)     b(c)     max(b(r), b(c))
 * 16*1    (4)   (4)    (2)      (2)             (2)
 * 16*4    (4)   (4)    (2)      (2)             (2)
 * 128*8   (16)  (8)    (4)      (3)             (4)
 * 512*4   (16)  (16)   (4)      (4)             (4)
 * 1024*4  (32)  (16)   (5)      (4)             (5)
 *
 *-----------------------------------------------------------------------------------------------
 *  练习题6.2:
 *
 *  磁盘容量计算 = 字节数/扇区 * 平均扇区数/磁道 * 磁道数/表面 * 表面数/盘面 * 盘面数/磁盘
 *
 *  计算这样一个磁盘的容量, 它有2个盘面，10000个柱面，每条磁道平均有400个扇区，而每个扇区有512个字节.
 *  容量 = 512 * 400 * 10000 * 2 * 2 = 8192000000 Bytes = 8.192GB
 *
 *-----------------------------------------------------------------------------------------------
 *  练习题6.3:
 *
 *  估计访问下面这个磁盘上一个扇区的访问时间(以ms为单位)
 *
 *  参数                  值
 *  旋转速率:             15000RPM
 *  T(avg seek)           8ms
 *  每条磁道的平均扇区数  500
 *
 *  访问一个磁盘扇区的平均时间 = 平均寻道时间 + 平均旋转延迟 + 平均传送时间
 *  平均寻道时间: 8ms
 *  平均旋转延迟: 60s / 15000RPM * 1/2 = 2ms
 *  平均传送时间: 60s / 15000RPM / 500 = 0.008ms
 *  访问时间: 8ms + 2ms + 0.008ms = 10.008ms
 *
 *-----------------------------------------------------------------------------------------------
 *  练习题6.4:
 *
 *  假设1MB的文件由512个字节的逻辑块组成，存储在具有如下特性的磁盘驱动器上:
 *
 *  参数               值
 *  旋转速率           10000RPM
 *  T(avg seek)        5ms
 *  平均扇区数/磁道    1000
 *  表面               4
 *  扇区大小           512字节
 *
 *  Q: 最好的情况，给定逻辑块到磁盘扇区的最好的可能的映射(即顺序的), 估计读这个文件需要的最优时间(以ms为单位)
 *  A: 最好的情况所有的逻辑块在同一个柱面上，我们可以连续的读取2000个逻辑块(2000*512Bytes=1MB)
 *     平均寻道时间: 5ms
 *     平均旋转延迟: 60s / 10000RPM * 1/2 = 3m
 *     读取一个扇区花费时间: 60s / 10000RPM / 1000 = 0.006ms
 *     读取1MB文件花费总时间: 5ms + 3ms + 2000*0.006ms = 20ms
 *
 *  Q: 随机的情况, 如果块是随机的映射到磁盘扇区的，估计读这个文件需要的时间(以ms为单位)
 *  A: 随机的情况就是所有的逻辑块随机部署在所有的柱面的所有扇区上，我们每次读取一个逻辑块都需要重新
 *     计算平均寻道时间以及旋转延迟
 *     读取1MB文件花费总时间: (5ms + 3ms + 0.006ms)*2000 = 16012ms
 *-----------------------------------------------------------------------------------------------
 *  练习题6.6:
 *
 * 正如我们已经看到的, SSD的一个潜在的缺陷是底层闪存会磨损. 例如，一个主要的制造商保证他们的SSD能够经得
 * 起1PB(10^15 Bytes)的随机写. 给定这样的假设，根据下面的工作负载，估计图6-16中的SSD的寿命(以年为单位)
 *
 * 1 MB = 10^6 Bytes
 * 1 PB = 10^(15-6) MB
 * Q: 顺序写的最糟情况: 以170MB/s(该设备的平均顺序写吞吐量)的速度持续的写SSD.
 * A: 10^9MB / 170MB / (60*60*24*365) = 0.186年
 *
 * Q: 随机写的最糟情况: 以14MB/s(该设备的平均随机写吞吐量)的速度持续的写SSD.
 * A: 10^9MB / 14MB  / (60*60*24*365) = 2.256年
 *
 * Q: 平均情况: 以20GB/天(某些计算机制造商在他们的移动计算机工作负载模拟测试中假设的平均每天写速率)的速度写SSD
 * A: 10^9MB / 20*(10^3)MB / 365 = 136.986年
 *----------------------------------------------------------------------------------------------
 *  练习题6.8:
 *
 *  改变下面函数中循环的顺序，使他以步长为1的引用模式臊面三维数组a:
 *
 *  int summarray3d(int a[N][N][N]) {
 *    int i, j, k, sum = 0;
 *    for (i = 0; i < N; i++) {
 *      for (j = 0; j < N; j++) {
 *        for (k = 0; k < N; k++) {
 *          sum += a[k][i][j]
 *        }
 *      }
 *    }
 *  }
 *
 *  修改之后:
 *  int summarray3d(int a[N][N][N]) {
 *    int i, j, k, sum = 0;
 *    for (i = 0; i < N; i++) {
 *      for (j = 0; j < N; j++) {
 *        for (k = 0; k < N; k++) {
 *          sum += a[i][j][k]
 *        }
 *      }
 *    }
 *  }
 *----------------------------------------------------------------------------------------------
 *  练习题6.9:
 *
 *  图6-22中的三个函数，以不同的空间局部程度, 执行相同的操作，请对这些函数就空间局部性进行排序,解
 *  释你是如何得到排序结果的.
 *
 *  主要是要弄清楚数组是如何在存储器中排列的，clear1函数无论是从结构体数组层面，还是成员变量int数组
 *  层面，都是以步长1访问的，无疑空间局部性是最好的，clear2函数从结构体数组层面，是以步长1访问的,
 *  但是在两个成员变量int数组层面却是跳来跳去的，空间局部性要比clear1差一些，clear3函数无论是结构体
 *  数组层面还是成员变量int数组层面都不是以步长1访问的，空间局部性最差
 *
 *  clear1 > clear2 > clear3
 *----------------------------------------------------------------------------------------------
 *  练习题6.10:
 *
 *  下标给出了几个不同的高速缓存的参数，确定每个高速缓存的高速缓存组数(S), 标记位数(t), 组索引位
 *  数(s),以及块偏移位数(b)
 *
 *  高速缓存的总容量为C，首先高速缓存拆分为S个组，每个组又有E行, 每行有B字节的数据块
 *  所以C = S * E * B
 *
 *  m表示每个存储器的地址有m位(排列为: |t位标记|s位组索引|b位块偏移量|)
 *
 *  t是标记位，t=m-(s+b)
 *  s表示组索引位数量
 *  b表示块偏移位数量
 *
 *  高速缓存      m      C      B      E      S      t      s      b
 *    1.          32     1024   4      1      256    22     8      2
 *    2.          32     1024   8      4      32     24     5      3
 *    3.          32     1024   32     32     1      27     0      5
 *----------------------------------------------------------------------------------------------
 *  练习题6.11:
 *
 *  Q: 在前面dotprod的例子中，在我们对数组x做了填充之后，所有对x和y的引用的命中率是多少?
 *
 *  A: 根据题意存储器的地址空间为[0 ~ 95], 所以存储器地址m为7位，而每个块有16个字节, 则块偏移
 *     位数量b为4, 高速缓存又两个组组成，组索引位数量s为1, 标记为t = m - (b + s), t = 2, 然后
 *     根据这些参数模拟一把就能得出命中率为3/4
 *----------------------------------------------------------------------------------------------
 * 练习题6.12:
 *
 * 一般而言，如果一个地址的高s位被用作组索引，那么存储器块连续的片(chunk)会被映射到同一个高速缓存组
 * Q: 每个这样的连续的数组片中有多少个块?
 * A: 用高位做组索引，则地址的组成形式为: |s位组索引|t位标记|b位块偏移量|, 会有2^t个连续的块被映射
 *    到组0，接下来2^t个连续的块被映射到组1, 以此类推
 *
 * Q: 考虑下面的代码，它运行在一个高速缓存形式为(S, E, B, m) = (512, 1, 32, 32)的系统上:
 *    int array[4096];
 *    for (i = 0; i < 4096; i++)
 *      sum += array[i]
 *    在任意时刻，存储在高速缓存中的数组块的最大数量为多少?
 * A: 有512个高速缓存组(得出组索引位数量为9)，每组一行，每行中的块大小为32 Bytes(得出块偏移位数量为5),
 *    而地址空间位m为32, 可以计算出标记位t = m - (s+b) = 18, 给出的高速缓存容量为512个32 Bytes的块, 而
 *    我们数组的由(4096*4)/32=512个块组成, 正好可以完全被高速缓存容纳
 *----------------------------------------------------------------------------------------------
 * 练习题6.13:
 *
 * 1  ~ 0 用于表示CO(高速缓存块偏移)
 * 4  ~ 2 用于表示CI(高速缓存组索引)
 * 12 ~ 5 用于表示CT(高速缓存标记)
 *----------------------------------------------------------------------------------------------
 * 练习题6.14:
 *
 * 假设一个程序运行在练习题6.13中的机器上，它引用地址0x0E34处的一个字节的字. 指出访问的高速缓存
 * 条目和十六进制表示的返回的高速缓存字节值. 指出是否会发生缓存不命中. 如果会出现缓存不命中，用
 * '-'来表示"返回的高速缓存字节"
 *
 * A. 地址格式(每个小方框一个位):
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        0  1  1   1  0  0  0  1  1  0  1  0  0
 * B. 存储器引用:
 *        参数                   值
 *        高速缓存块偏移(CO)     0x00
 *        高速缓存组索引(CI)     0x05
 *        高速缓存标记  (CT)     0x71
 *        高速缓存命中  (是/否)  是
 *        返回的高速缓存字节     0B
 *----------------------------------------------------------------------------------------------
 * 练习题6.15:
 *
 * 对于存储器地址0x0DD5, 再做一遍练习题6.14.
 *
 * A. 地址格式(每个小方框一个位):
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        0  1  1   0  1  1  1  0  1  0  1  0  1
 * B. 存储器引用:
 *        参数                   值
 *        高速缓存块偏移(CO)     0x01
 *        高速缓存组索引(CI)     0x05
 *        高速缓存标记  (CT)     0x6E
 *        高速缓存命中  (是/否)  否
 *        返回的高速缓存字节     -
 *----------------------------------------------------------------------------------------------
 * 练习题6.16:
 *
 * 对于存储器地址0x1FE4, 再做一遍练习题6.14.
 *
 * A. 地址格式(每个小方框一个位):
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        1  1  1   1  1  1  1  1  0  0  1  0  0
 * B. 存储器引用:
 *        参数                   值
 *        高速缓存块偏移(CO)     0x00
 *        高速缓存组索引(CI)     0x01
 *        高速缓存标记  (CT)     0xFF
 *        高速缓存命中  (是/否)  否
 *        返回的高速缓存字节     -
 *----------------------------------------------------------------------------------------------
 * 练习题6.17:
 *
 * Q: 对于练习题6.13中的高速缓存，列出所有的在组3中会命中的十六进制存储器地址
 *
 * A: 组三只包含一个有效行，标记位为CT = 0x32, 高速缓存组索引为CI=0x03, CT和CI为固定位，如下图，块
 *    偏移CO占据两Bits, 所以总共有四个地址会命中(CO的取值可以为00, 01, 10, 11),
 *    地址格式:
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        0  0  1   1  0  0  1  0  0  1  1  x  x
 *        |----------CT---------|  |--CI-|  |CO|
 *    命中地址:
 *        0x064C
 *        0x064D
 *        0x064E
 *        0x064F
 *----------------------------------------------------------------------------------------------
 * 练习题6.18:
 *
 * 在型号处理和科学计算的应用中，转置矩阵的行和列是一个很重要的问题. 从局部性的角度来看，它也很有
 * 趣，因为它的引用模式既是以行为主(row-wise)的，也是以列为主(column-wise)的. 例如, 考虑下面的转
 * 置函数:
 *
 * typedef int array[2][2];
 *  void transpose1(array dst, array src) {
 *    int i, j;
 *    for (i = 0; i < 2; i++) {
 *      for (j = 0; j < 2; j++) {
 *        dst[j][i] = src[i][j]
 *      }
 *    }
 *  }
 *
 *  假设在一台具有如下属性的机器上运行这段代码:
 *  # sizeof(int) == 4
 *  # src数组从地址0开始，dst数组从地址16开始(十进制).
 *  # 只有一个L1数据高速缓存，它是直接映射的，直写，写分配，块大小为8 Bytes.
 *  # 这个高速缓存的总的大小为16 Bytes，一开始是空的.
 *  # 对src和dst数组的访问分别是读和写不命中的唯一来源.
 *
 *  Q1: 对每个row和col, 指明对src[row][col]和dst[row][col]的访问是命中(h)还
 *  是不命中(m), 例如, 读src[0][0]会不命中，写dst[0][0]也不命中.
 *
 *
 *  A: 缓存是直接映射的，并且总大小为16 Bytes, 块大小为8 Bytes, 也就是说有两个
 *     高速缓存组，每个高速缓存组中只有一个高速缓存行, 地址空间为[0 ~ 31], 地址
 *     位数量m为5 组索引位数量s为1, 块偏移位数量b为3, 标记位数量t为1(t=m-(s+b))
 *
 *     0:  src[0][0] src[0][1] src[1][0] src[1][1]
 *     16: dst[0][0] dst[0][1] dst[1][0] dst[1][1]
 *
 *     访问src[0][0]时缓存
 *     组一缓存 src[0][0] src[0][1] 不命中
 *     组二缓存 null
 *     访问dst[0][0]时缓存
 *     组一缓存 dst[0][0] dst[0][1] 不命中
 *     组二缓存 null
 *
 *     访问src[0][1]时缓存
 *     组一缓存 src[0][0] src[0][1] 不命中
 *     组二缓存 null
 *     访问dst[1][0]时缓存
 *     组一缓存 src[0][0] src[0][1]
 *     组二缓存 dst[1][0] dst[1][1] 不命中
 *
 *     访问src[1][0]时缓存
 *     组一缓存 src[0][0] src[0][1]
 *     组二缓存 src[1][0] src[1][1] 不命中
 *     访问dst[0][1]时缓存
 *     组一缓存 dst[0][0] dst[0][1] 不命中
 *     组二缓存 src[1][0] src[1][1]
 *
 *
 *     访问src[1][1]时缓存
 *     组一缓存 dst[0][0] dst[0][1]
 *     组二缓存 src[1][0] src[1][1] 命中
 *
 *     访问dst[1][1]时缓存
 *     组一缓存 dst[1][0] dst[1][1] 不命中
 *     组二缓存 src[1][0] src[1][1]
 *
 *           dst数组              src数组
 *           列0   列1            列0   列1
 *     0行   m     m        0行   m     m
 *     1行   m     m        1行   m     h
 *
 *  Q1: 对于一个大小为32数据字节的高速缓存重复这个练习
 *
 *  A: 缓存是直接映射的，并且总大小为32 Bytes, 块大小为8 Bytes, 也就是说有四个
 *     高速缓存组，每个高速缓存组中只有一个高速缓存行, 地址空间为[0 ~ 31], 地址
 *     位数量m为5 组索引位数量s为1, 块偏移位数量b为3, 标记位数量t为1(t=m-(s+b))
  *
 *           dst数组              src数组
 *           列0   列1            列0   列1
 *     0行   m     h        0行   m     h
 *     1行   m     h        1行   m     h
 *----------------------------------------------------------------------------------------------
 * 练习题6.19:
 *
 * 最近一个很成功的游戏SimAquarium的核心就是一个紧密循环(tight loop), 它计算256个海藻(algae)的平
 * 均位置. 在一台具有块大小为16字节(B=16), 整个大小为1024字节的直接映射数据缓存的机器上测量它的
 * 高速缓存性能. 定义如下:
 *
 * struct algae_position {
 *   int x;
 *   int y;
 * };
 *
 * struct algae_position grid[16][16];
 * int total_x = 0, total_y = 0;
 * int i, j;
 *
 * 还有如下假设:
 * # sizeof(int) == 4
 * # grid从存储器地址0开始
 * # 这个高速缓存开始时是空的
 * # 唯一的存储器访问是对数组grid的元素的访问. 变量i, j, total_x和total_y存放在寄存器中
 * 确定下面代码的高速缓存性能:
 * for (i = 0; i < 16; i++) {
 *   for (j = 0; j < 16; j++) {
 *     total_x += grid[i][j].x
 *   }
 * }
 *
 * for (i = 0; i < 16; i++) {
 *   for (j = 0; j < 16; j++) {
 *     total_y += grid[i][j].y
 *   }
 * }
 *
 * 直接高速缓存，并且总容量为1024 Bytes, 每个块为16 Bytes, 可以得出有64个高速缓存组, 每个高速缓存组有一个高速缓存行
 * 存储器地址的取值范围为[0, 2048), 地址m的位数为11, 组索引位数量s=6, 块偏移位数量b=4, 标记位数量t=(11-6-4)=1,
 *
 * Q1: 总读数是多少?
 * A1: 总读数为512(16 * 16 * 2)
 * Q2: 缓存不命中的总读数是多少?
 * A2: 循环模式为不命中，命中，不命中，命中..., 缓存不命中的总读数为256
 * Q3: 不命中率是多少?
 * A3: 不命中率为50%(不命中总数/总读数)
 *----------------------------------------------------------------------------------------------
 * 练习题6.20:
 *
 * 给定练习题6.19的假设，确定下列代码的高速缓存性能:
 * for (i = 0; i < 16; i++) {
 *  for (j = 0; j < 16; j++) {
 *    total_x += grid[i][j].x
 *    total_y += grid[i][j].y
 *  }
 * }
 *
 * Q1: 总的读数是多少?
 * A1: 总读数为512（16 * 16 * 2)
 * Q2: 高速缓存不命中的读总数是多少?
 * A2: 循环模式为不命中, 命中，命中，命中，不命中, 命中, 命中, 命中, 缓存不命中的总读数为128
 * Q3: 不命中率是多少?
 * A3: 不命中率为25%(不命中总数/总读数)
 * Q4: 如果缓存有两倍大，那么不命中率会是多少呢?
 * A4: 如果在高速缓存块大小不变的前提下将缓存容量提升两倍，说明只是将高速缓存组的数量变多, 不
 *     命中率依然还是25%, 因为冷不命中是无法避免的
 *
 *
 */






