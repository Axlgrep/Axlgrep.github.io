/*
 * 第六章:并发编程
 *
 * 摘要: axx
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题12.1:
 *
 * 在图12-5中, 并发服务器的第33行, 父进程关闭了已连接的描述符后, 子进程仍然能够使用该描述符和客户
 * 端通信, 这是为什么?
 *
 * 进程拥有自己的独立的描述符表, 但是打开文件的集合由一张文件表表示, 所有进程共享这张表, 进程fork()
 * 了一个子进程之后, 子进程有父进程描述符表的副本，并且相关文件表中的引用计数从1增加到2, 父进程关闭
 * 了已连接的描述符之后，只不过将文件表中相应条目的引用计数从2减到1, 此时文件并不会被关闭, 所以子进
 * 程仍然可以继续使用该描述符
 *-----------------------------------------------------------------------------------------------
 * 练习题12.2:
 *
 * 如果我们要删除图12-5中关闭已连接描述符的第30行, 从没有存储器泄露的角度来说，代码将仍然是正确的,
 * 这是为什么?
 *
 * 30行是子进程的逻辑, 子进程exit(0)退出之后会销毁自己的描述符表，内核将关闭所有打开的描述符，因此,
 * 当子进程退出时, 它的已连接文件描述符的副本也将被自动关闭
 *-----------------------------------------------------------------------------------------------
 * 练习题12.3:
 *
 * 在大多数Unix系统里, 在标准输入键入ctrl-d表示EOF, 在12.6中的程序阻塞在对select的调用上时, 如果你
 * 键入ctrl-d会发生什么?
 *
 * 如果从一个描述符中读一个字节的请求不会阻塞, 那么这个描述符就准备好可以读了, 假如EOF在一个描述符
 * 上为真, 那么描述符也准备好可读了, 因为读操作将立即返回一个零返回码, 表示EOF. 因此, 键入ctrl-d会
 * 导致select函数返回, 准备好的集合中有描述符0.
 *-----------------------------------------------------------------------------------------------
 * 练习题12.4:
 *
 * 在如图12-8所示的服务器中，我们在每次调用select之前都立即小心地重新初始化pool.ready_set变量，这是
 * 为什么?
 *
 * 因为变量pool.read_set即作为输入参数，也作为输出参数，所以我们再每一次调用select之前都重新初始化它,
 * 在输入时, 它包含读集合, 在输出时, 它包含准备好的集合.
 *-----------------------------------------------------------------------------------------------
 * 练习题12.5:
 *
 * 在图12-5中基于进程的服务器中, 我们在两个位置小心地关闭了已连接描述符:父进程和子进程. 然而, 在图12-14
 * 中基于线程的服务器中, 我们只在一个位置关闭了已连接描述符:对等线程, 这是为什么?
 *
 * 基于进程的服务器中, 父子进程都有各自的描述符表, 文件表中已连接描述符的引用计数为2, 而基于线程的服务器
 * 中, 由于运行在同一个进程当中，所以它们共享同一张描述符表，文件表中已连接描述符的引用计数为1, 当我们将
 * 其使用完毕之后，在任意一个线程里面调用一次close()就可以释放该描述符相关的存储器资源了
 *-----------------------------------------------------------------------------------------------
 * 练习题12.6:
 *
 * 利用12.4节中的分析, 为图12-15中的示例程序在下表中的每个条目中填写是或者否. 在第一列中, 符号v.t表示变量
 * v的一个实例, 它驻留在线程t的本地栈中, 其中t要么是m(主线程), 要么是p0(对等线程0)或者p1(对等线程1).
 *
 * 变量实例     主线程引用的?         对等线程0引用的?          对等线程1引用的?
 * ptr               是                     是                         是
 * cnt               否                     是                         是
 * i.m               是                     否                         否
 * msgs.m            是                     是                         是
 * myid.p0           否                     是                         否
 * myid.p1           否                     否                         是
 *
 * ptr: 是一个被主线程写和对等线程读的全局变量.
 * cnt: 一个静态变量, 在存储器中只有一个实例, 被两个对等线程读和写
 * i.m: 一个存储在主线程栈中的本地自动变量. 虽然它的值被传递给对等线程,
 *      但是对等线程也绝不会再栈中引用它, 因此它不是共享的
 * msg.m: 一个存储在主线程栈中的本地自动变量, 被两个对等线程通过ptr间接引用
 * myid.p0和myid.p1: 一个本地自动变量的实例, 分别驻留在对等线程p0和p1的栈中
 *
 * 根据A部分的分析, 变量ptr, cnt, i, msgs和myid哪些是共享的
 *
 * 变量ptr, cnt, msgs被多余一个线程引用，因此他们是共享的
 *-----------------------------------------------------------------------------------------------
 * 练习题12.7:
 *
 * 根据badcnt.c的指令顺序完成下表:
 *
 * 步骤    线程    指令    %exa1   %eax2    cnt
 *  1       1       H1       -       -       0
 *  2       1       L1       0       -       0
 *  3       2       H2       -       -       0
 *  4       2       L2       -       0       0
 *  5       2       U2       -       1       0
 *  6       2       S2       -       1       1
 *  7       1       U1       1       -       1
 *  8       1       S1       1       -       1
 *  9       1       T1       1       -       1
 *  10      2       T2       -       1       1
 *
 *  这种顺序会产生一个正确的cnt值吗?
 *  不会，最终会产生一个不正确的cnt值(1)
 *-----------------------------------------------------------------------------------------------
 * 练习题12.8:
 *
 * 使用图12-21中的进度图, 将下列轨迹线划分为安全的或者不安全的.
 * A. H1,L1,U1,S1,H2,L2,U2,S2,T2,T1 (安全)
 * B. H2,L2,H1,L1,U1,S1,T1,U2,S2,T2 (不安全)
 * C. H1,H2,L2,U2,S2,L1,U1,S1,T1,T2 (安全)
 *-----------------------------------------------------------------------------------------------
 * 练习题12.9:
 *
 * 设p表示生产者数量, c表示消费者数量, 而n表示以项目单元为单位的缓冲区大小, 对于下面的每个场景, 指
 * 出sbuf_insert和sbuf_remove中的互斥锁信号量是否是必须的.
 *
 * A. p=1, c=1, n>1 (需要互斥锁, 因为生产者和消费者会并发的访问缓冲区)
 * B. p=1, c=1, n=1 (无需互斥锁, 因为一个非空的缓冲区就等于满的缓冲区, 当缓冲区包含一个项目时, 生产
 *                   者就被阻塞了，反之, 当缓冲区为空时, 消费者就被阻塞了, 所以在任意时刻, 只有一个
 *                   线程可以访问缓冲区, 因此无需互斥锁也能保证访问互斥)
 * C. p>1, c>1, n=1 (无需互斥锁, 理由同B一样)
 */
