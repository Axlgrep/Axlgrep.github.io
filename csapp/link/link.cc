/*
 * 第七章: 链接
 *
 * 摘要:
 *
 *
 * 可重定位目标文件:
 *   .text     : 已编译程序的机器代码.
 *   .rodata   : 只读数据(readonly data), 比如printf语句中的格式串和开关语句的跳转表
 *   .data     : 已初始化的全局C变量, 局部C变量在运行时保存在栈中, 既不出现在.data节中, 也不
 *               出现在.bss节中
 *   .bss      : 未初始化的全局C变量，在目标文件中这个节不占据实际的空间，它仅仅是一个占位符,
 *               目标文件格式区分初始化和未初始化变量是为了空间效率, 在目标文件中, 未初始化变
 *               量不需要占据任何实际的磁盘空间
 *   .symtab   : 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息. 一些程序员错误的
 *               认为必须通过-g选项来编译程序才能得到符号表信息. 实际上, 每个可重定位目标文件
 *               在.symtab中都有一张符号表. 然而，和编译器中的符号表不同, .symtab符号表不包含
 *               局部变量的条目
 *   .rel.text : 一个.text节中位置的列表, 当链接器把这个目标文件和其他文件结合时, 需要修改这些
 *               位置. 一般而言, 任何调用外部函数或者引用全局变量的指令都需要修改. 另一方面, 调
 *               用本地函数的指令则不需要修改. 注意, 可执行目标文件中并不需要重定位信息, 因此
 *               通常省略, 除非用户显示地指示链接器包含这些信息
 *   .rel.data : 被模块引用或定义的任何全局变量的重定位信息. 一般而言, 任何已初始化的全局变量,
 *               如果它的初始值是一个全局变量地址或者外部定义函数的地址, 都需要被修改
 *   .debug    : 一个调试符号表, 其条目时程序中定义的局部变量和类型定义, 程序中定义和引用的全局
 *               变量, 以及原始C源文件. 只有以-g选项调用编译驱动程序时才会得到这张表
 *   .line     : 原始C源程序中的行号和.text节中机器指令之间的映射. 只有以-g选项调用编译驱动程序
 *               时才会得到这张表
 *   .strtab   : 一个字符串表, 其内容包括.symtab和.debug节中的符号表, 以及节头部中的节名字. 字
 *               符串表就是以null结尾的字符串序列
 *
 *
 *
 *
 *
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题7.1:
 *
 * 这个题目是关于图7-1b中的swap.o模块, 对于每个在swap.o中定义或引用的符号,请指出它是否在模块swap.o
 * 中的.symtab节中有一个符号表条目.如果是,请指出定义该符号的模块(swap.o或者main.o), 符号类型(本地,
 * 全局或者外部)和它在模块中占据的节(.text, .data或者.bss).
 *
 * 符号         swap.o .symtab条目?   符号类型   在哪个模块中定义   节
 * buf          是                    外部       main.o中定义       .data
 * bufp0        是                    全局       swap.o中定义       .data
 * bufp1        是                    全局       swap.o中定义       .bss
 * swap         是                    全局       swap.o中定义       .text
 * temp         否                    -          -                  -
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题7.2:
 *
 * 在此题中, REF(x.i) --> DEF(x.k)表示链接器将把模块i中对符号x的任意引用与模块k中x的定义联系起来.
 * 对于下面的每个示例,用这种表示法来说明链接器将如何解析每个模块中对多重定义符号的引用.如果有一个
 * 链接时错误(规则1), 写"ERROR". 如果链接器从定义中任意选择一个(规则3), 则写"UNKNOWN"
 *
 * A  * Module 1 *    * Module 2 *
 *    int main() {}   int main;
 *                    int p2() {}
 *
 *    module 1里的main强定义, module 2里的
 *    main弱定义
 *    (a) REF(main.1) --> DEF(main.1)
 *    (b) REF(main.2) --> DEF(main.1)
 *
 * B  * Module 1 *    * Module 2 *
 *    void main() {}  int main=1;
 *                    int p2() {}
 *
 *    moudle 1里的main强定义, module 2里的
 *    main也是强定义
 *    (a) REF(main.1) --> DEF()   ERROR
 *    (b) REF(main.2) --> DEF()   ERROR
 *
 * C  * Module 1 *    * Module 2 *
 *    int x;          double x=1.0;
 *    void main() {}  int p2() {}
 *
 *    module 1里的x只定义了, 没有初始化,
 *    为弱定义, module 2里的x为强定义
 *    (a) REF(x.1) --> DEF(x.2)
 *    (b) REF(x.2) --> DEF(x.2)
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题7.3:
 *
 * a和b表示当前目录中的目标模块或者静态库, 而a->b表示a依赖于b, 也就是说b定义了一个被a引用的符号,
 * 对于下面每种场景,请给出最小的命令行(也就是一个含有最少数量的目标文件和库参数的命令), 使得静态
 * 链接器能解析所有的符号引用
 *
 * A. p.o -> libx.a.
 *    gcc p.o libx.a
 * B. p.o -> libx.a ->liby.a
 *    gcc p.o libx.a liby.a
 * C. p.o -> libx.a ->liby.a 且 liby.a ->libx.a -> p.o
 *    gcc p.o libx.a liby.a libx.a
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题7.4:
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题7.5:
 *
 * A: 为什么每个C程序都需要一个叫做main的函数
 *    每个程序都需要一个main函数,因为C的启动代码对于每个C程序而言都是相同的,要跳转到一个叫做main
 *    的函数上
 * B: 你想过为什么C的main函数可以通过调用exit或者执行一条return语句来结束,
 *    或者两者都不做, 而程序仍然可以正确的终止吗?请解释
 *    如果main以return语句终止,那么控制传递回启动程序,该程序通过调用_exit再将控制返回给操作系统,如
 *    果用户省略了return语句,也会发生相同的情况.如果main是以调用exit终止的,那么exit将最终通过调用
 *    _exit将控制返回给操作系统.在这三种情况中,最终效果是相同的:当main完成时,控制会返回给操作系统
