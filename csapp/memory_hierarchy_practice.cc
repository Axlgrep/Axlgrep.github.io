/*
 * 第六章:存储器层次结构
 *
 * 摘要: 随机访问存储器(Random-Access Memory, RAM)又分为静态随机存储器(SRAM, 也就是L1，L2, L3等
 *       高速缓存)和动态随机存储器(DRAM, 主存)
 *       只读存储器(Read-Only Memory, ROM)
 *       闪存(Flash Memory)
 *       从磁盘上读信息的时间在毫秒级，从DRAM读比从磁盘读快10w倍，从SRAM读比从磁盘读快100w倍
 *
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题6.1:
 *
 * 接下来，设r表示一个DRAM阵列中的行数，c表示列数，b(r)表示行寻址所需的位数，b(c)表示列寻址所需的位数,
 * 对于下面每个DRAM, 确定2的幂数的阵列维数，使得max(b(r), b(c))最小，max(b(r), b(c))是对阵列的行或者
 * 列寻址所需的位数中较大的值.
 *
 * 要使寻址所需位数最小，我们需要将数组组织成尽可能接近与正方形的样子
 * 16   -> 4  * 4
 * 128  -> 16 * 8
 * 512  -> 16 * 16
 * 1024 -> 32 * 16
 *
 * 组织     r     c     b(r)     b(c)     max(b(r), b(c))
 * 16*1    (4)   (4)    (2)      (2)             (2)
 * 16*4    (4)   (4)    (2)      (2)             (2)
 * 128*8   (16)  (8)    (4)      (3)             (4)
 * 512*4   (16)  (16)   (4)      (4)             (4)
 * 1024*4  (32)  (16)   (5)      (4)             (5)
 *
 *-----------------------------------------------------------------------------------------------
 *  练习题6.2:
 *
 *  磁盘容量计算 = 字节数/扇区 * 平均扇区数/磁道 * 磁道数/表面 * 表面数/盘面 * 盘面数/磁盘
 *
 *  计算这样一个磁盘的容量, 它有2个盘面，10000个柱面，每条磁道平均有400个扇区，而每个扇区有512个字节.
 *  容量 = 512 * 400 * 10000 * 2 * 2 = 8192000000 Bytes = 8.192GB
 *
 *-----------------------------------------------------------------------------------------------
 *  练习题6.3:
 *
 *  估计访问下面这个磁盘上一个扇区的访问时间(以ms为单位)
 *
 *  参数                  值
 *  旋转速率:             15000RPM
 *  T(avg seek)           8ms
 *  每条磁道的平均扇区数  500
 *
 *  访问一个磁盘扇区的平均时间 = 平均寻道时间 + 平均旋转延迟 + 平均传送时间
 *  平均寻道时间: 8ms
 *  平均旋转延迟: 60s / 15000RPM * 1/2 = 2ms
 *  平均传送时间: 60s / 15000RPM / 500 = 0.008ms
 *  访问时间: 8ms + 2ms + 0.008ms = 10.008ms
 *
 *-----------------------------------------------------------------------------------------------
 *  练习题6.4:
 *
 *  假设1MB的文件由512个字节的逻辑块组成，存储在具有如下特性的磁盘驱动器上:
 *
 *  参数               值
 *  旋转速率           10000RPM
 *  T(avg seek)        5ms
 *  平均扇区数/磁道    1000
 *  表面               4
 *  扇区大小           512字节
 *
 *  Q: 最好的情况，给定逻辑块到磁盘扇区的最好的可能的映射(即顺序的), 估计读这个文件需要的最优时间(以ms为单位)
 *  A: 最好的情况所有的逻辑块在同一个柱面上，我们可以连续的读取2000个逻辑块(2000*512Bytes=1MB)
 *     平均寻道时间: 5ms
 *     平均旋转延迟: 60s / 10000RPM * 1/2 = 3m
 *     读取一个扇区花费时间: 60s / 10000RPM / 1000 = 0.006ms
 *     读取1MB文件花费总时间: 5ms + 3ms + 2000*0.006ms = 20ms
 *
 *  Q: 随机的情况, 如果块是随机的映射到磁盘扇区的，估计读这个文件需要的时间(以ms为单位)
 *  A: 随机的情况就是所有的逻辑块随机部署在所有的柱面的所有扇区上，我们每次读取一个逻辑块都需要重新
 *     计算平均寻道时间以及旋转延迟
 *     读取1MB文件花费总时间: (5ms + 3ms + 0.006ms)*2000 = 16012ms
 *-----------------------------------------------------------------------------------------------
 *  练习题6.6:
 *
 * 正如我们已经看到的, SSD的一个潜在的缺陷是底层闪存会磨损. 例如，一个主要的制造商保证他们的SSD能够经得
 * 起1PB(10^15 Bytes)的随机写. 给定这样的假设，根据下面的工作负载，估计图6-16中的SSD的寿命(以年为单位)
 *
 * 1 MB = 10^6 Bytes
 * 1 PB = 10^(15-6) MB
 * Q: 顺序写的最糟情况: 以170MB/s(该设备的平均顺序写吞吐量)的速度持续的写SSD.
 * A: 10^9MB / 170MB / (60*60*24*365) = 0.186年
 *
 * Q: 随机写的最糟情况: 以14MB/s(该设备的平均随机写吞吐量)的速度持续的写SSD.
 * A: 10^9MB / 14MB  / (60*60*24*365) = 2.256年
 *
 * Q: 平均情况: 以20GB/天(某些计算机制造商在他们的移动计算机工作负载模拟测试中假设的平均每天写速率)的速度写SSD
 * A: 10^9MB / 20*(10^3)MB / 365 = 136.986年
 *----------------------------------------------------------------------------------------------
 *  练习题6.8:
 *
 *  改变下面函数中循环的顺序，使他以步长为1的引用模式臊面三维数组a:
 *
 *  int summarray3d(int a[N][N][N]) {
 *    int i, j, k, sum = 0;
 *    for (i = 0; i < N; i++) {
 *      for (j = 0; j < N; j++) {
 *        for (k = 0; k < N; k++) {
 *          sum += a[k][i][j]
 *        }
 *      }
 *    }
 *  }
 *
 *  修改之后:
 *  int summarray3d(int a[N][N][N]) {
 *    int i, j, k, sum = 0;
 *    for (i = 0; i < N; i++) {
 *      for (j = 0; j < N; j++) {
 *        for (k = 0; k < N; k++) {
 *          sum += a[i][j][k]
 *        }
 *      }
 *    }
 *  }
 *----------------------------------------------------------------------------------------------
 *  练习题6.9:
 *
 *  图6-22中的三个函数，以不同的空间局部程度, 执行相同的操作，请对这些函数就空间局部性进行排序,解
 *  释你是如何得到排序结果的.
 *
 *  主要是要弄清楚数组是如何在存储器中排列的，clear1函数无论是从结构体数组层面，还是成员变量int数组
 *  层面，都是以步长1访问的，无疑空间局部性是最好的，clear2函数从结构体数组层面，是以步长1访问的,
 *  但是在两个成员变量int数组层面却是跳来跳去的，空间局部性要比clear1差一些，clear3函数无论是结构体
 *  数组层面还是成员变量int数组层面都不是以步长1访问的，空间局部性最差
 *
 *  clear1 > clear2 > clear3
 *----------------------------------------------------------------------------------------------
 *  练习题6.10:
 *
 *  下标给出了几个不同的高速缓存的参数，确定每个高速缓存的高速缓存组数(S), 标记位数(t), 组索引位
 *  数(s),以及块偏移位数(b)
 *
 *  高速缓存的总容量为C，首先高速缓存拆分为S个组，每个组又有E行, 每行有B字节的数据块
 *  所以C = S * E * B
 *
 *  m表示每个存储器的地址有m位(排列为: |t位标记|s位组索引|b位块偏移量|)
 *
 *  t是标记位，t=m-(s+b)
 *  s表示组索引位数量
 *  b表示块偏移位数量
 *
 *  高速缓存      m      C      B      E      S      t      s      b
 *    1.          32     1024   4      1      256    22     8      2
 *    2.          32     1024   8      4      32     24     5      3
 *    3.          32     1024   32     32     1      27     0      5
 *----------------------------------------------------------------------------------------------
 *  练习题6.11:
 *
 *  Q: 在前面dotprod的例子中，在我们对数组x做了填充之后，所有对x和y的引用的命中率是多少?
 *
 *  A: 根据题意存储器的地址空间为[0 ~ 95], 所以存储器地址m为7位，而每个块有16个字节, 则块偏移
 *     位数量b为4, 高速缓存又两个组组成，组索引位数量s为1, 标记为t = m - (b + s), t = 2, 然后
 *     根据这些参数模拟一把就能得出命中率为3/4
 *----------------------------------------------------------------------------------------------
 * 练习题6.12:
 *
 * 一般而言，如果一个地址的高s位被用作组索引，那么存储器块连续的片(chunk)会被映射到同一个高速缓存组
 * Q: 每个这样的连续的数组片中有多少个块?
 * A: 用高位做组索引，则地址的组成形式为: |s位组索引|t位标记|b位块偏移量|, 会有2^t个连续的块被映射
 *    到组0，接下来2^t个连续的块被映射到组1, 以此类推
 *
 * Q: 考虑下面的代码，它运行在一个高速缓存形式为(S, E, B, m) = (512, 1, 32, 32)的系统上:
 *    int array[4096];
 *    for (i = 0; i < 4096; i++)
 *      sum += array[i]
 *    在任意时刻，存储在高速缓存中的数组块的最大数量为多少?
 * A: 有512个高速缓存组(得出组索引位数量为9)，每组一行，每行中的块大小为32 Bytes(得出块偏移位数量为5),
 *    而地址空间位m为32, 可以计算出标记位t = m - (s+b) = 18, 给出的高速缓存容量为512个32 Bytes的块, 而
 *    我们数组的由(4096*4)/32=512个块组成, 正好可以完全被高速缓存容纳
 *----------------------------------------------------------------------------------------------
 * 练习题6.13:
 *
 * 1  ~ 0 用于表示CO(高速缓存块偏移)
 * 4  ~ 2 用于表示CI(高速缓存组索引)
 * 12 ~ 5 用于表示CT(高速缓存标记)
 *----------------------------------------------------------------------------------------------
 * 练习题6.14:
 *
 * 假设一个程序运行在练习题6.13中的机器上，它引用地址0x0E34处的一个字节的字. 指出访问的高速缓存
 * 条目和十六进制表示的返回的高速缓存字节值. 指出是否会发生缓存不命中. 如果会出现缓存不命中，用
 * '-'来表示"返回的高速缓存字节"
 *
 * A. 地址格式(每个小方框一个位):
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        0  1  1   1  0  0  0  1  1  0  1  0  0
 * B. 存储器引用:
 *        参数                   值
 *        高速缓存块偏移(CO)     0x00
 *        高速缓存组索引(CI)     0x05
 *        高速缓存标记  (CT)     0x71
 *        高速缓存命中  (是/否)  是
 *        返回的高速缓存字节     0B
 *----------------------------------------------------------------------------------------------
 * 练习题6.15:
 *
 * 对于存储器地址0x0DD5, 再做一遍练习题6.14.
 *
 * A. 地址格式(每个小方框一个位):
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        0  1  1   0  1  1  1  0  1  0  1  0  1
 * B. 存储器引用:
 *        参数                   值
 *        高速缓存块偏移(CO)     0x01
 *        高速缓存组索引(CI)     0x05
 *        高速缓存标记  (CT)     0x6E
 *        高速缓存命中  (是/否)  否
 *        返回的高速缓存字节     -
 *----------------------------------------------------------------------------------------------
 * 练习题6.16:
 *
 * 对于存储器地址0x1FE4, 再做一遍练习题6.14.
 *
 * A. 地址格式(每个小方框一个位):
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        1  1  1   1  1  1  1  1  0  0  1  0  0
 * B. 存储器引用:
 *        参数                   值
 *        高速缓存块偏移(CO)     0x00
 *        高速缓存组索引(CI)     0x01
 *        高速缓存标记  (CT)     0xFF
 *        高速缓存命中  (是/否)  否
 *        返回的高速缓存字节     -
 *----------------------------------------------------------------------------------------------
 * 练习题6.17:
 *
 * Q: 对于练习题6.13中的高速缓存，列出所有的在组3中会命中的十六进制存储器地址
 *
 * A: 组三只包含一个有效行，标记位为CT = 0x32, 高速缓存组索引为CI=0x03, CT和CI为固定位，如下图，块
 *    偏移CO占据两Bits, 所以总共有四个地址会命中(CO的取值可以为00, 01, 10, 11),
 *    地址格式:
 *        12 11 10  9  8  7  6  5  4  3  2  1  0
 *        0  0  1   1  0  0  1  0  0  1  1  x  x
 *        |----------CT---------|  |--CI-|  |CO|
 *    命中地址:
 *        0x064C
 *        0x064D
 *        0x064E
 *        0x064F
 */
