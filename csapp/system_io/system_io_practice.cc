/*
 * 第十章:系统级I/O
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题10.1:
 *
 * 下面程序的输出是什么?
 *
 * #include "csapp.h"
 *
 * int main() {
 *   int fd1, fd2;
 *   fd1 = Open("foo.txt", O_RDONLY, 0);
 *   Close(fd1);
 *   fd2 = Open("baz.txt", O_RDONLY, 0);
 *   printf("fd2 = %d\n", fd2)
 *   exit(0)
 * }
 *
 * 输出fd2 = 3, 每个进程开始时都有三个打开的文件, 标准输入(描述符为0, STDIN_FILENO), 标准输出(描述符
 * 为1, STDOUT_FILENO)和标准错误(描述符为2, STDERR_FILENO), 而open函数返回的描述符总是在进程中当前没
 * 有打开的最小描述符(f1为3, 但是close之后把3归还了, 所以fd2将使用3这个描述符)
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题10.2:
 *
 * 假设磁盘文件foobar.txt由六个ASCLL码字符"foobar"组成, 那么, 下列程序的输出是什么?
 *
 * #include "csapp.h"
 *
 * int main() {
 *   int fd1, fd2;
 *   char c;
 *
 *   fd1 = open("foobar.txt", O_RDONLY, 0);
 *   fd2 = open("foobar.txt", O_RDONLY, 0);
 *   read(fd1, &c, 1);
 *   read(fd2, &c, 1);
 *   printf("c = %c\n", c);
 *   exit(0);
 * }
 *
 * 输出c = f, 进程两次open同一个文件会生成两个不同的文件表, 文件表中独立记录当前的文件位置
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题10.3:
 *
 * 就像前面那样, 假设磁盘文件foobar.txt由六个ASCLL码字符"foobar"组成，那么下列程序的输出是什么?
 *
 * #include "csapp.h"
 *
 * int main() {
 *   int fd;
 *   char c;
 *
 *   fd = open("foobar.txt", O_RDONLY, 0);
 *   if (fork() == 0) {
 *     read(fd, &c, 1);
 *     exit(0);
 *   }
 *   wait(NULL);
 *   read(fd, &c, 1);
 *   printf("c = %c\n", c);
 *   exit(0);
 * }
 *
 * 输出c = o, fork之后, 父进程和子进程共享同一张文件表, 子进程读取一个字节后，文件表中的文件位
 * 置为1, 父进程会读取第二个字节
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题10.4:
 *
 * 如何用dup2将标准输入重定向到描述符5?
 *
 * 重定向标准输入(描述符0)到描述符5, 我们将调用dup2(5, 0), 或者等价的dup2(5, STDIN_FILENO)
 *
 *-----------------------------------------------------------------------------------------------
 * 练习题10.4:
 *
 * 假设磁盘文件foobar.txt由六个ASCLL码字符"foobar"组成，那么下列程序的输出是什么?
 *
 * #include "csapp.h"
 *
 * int main() {
 *   int fd1, fd2;
 *   char c;
 *
 *   fd1 = open("foobar.txt", O_RDONLY, 0);
 *   fd2 = open("foobar.txt", O_RDONLY, 0);
 *   read(fd2, &c, 1);
 *   dup2(fd2, fd1);
 *   read(fd1, &c, 1);
 *   printf("c = %c\n", c);
 *   exit(0):
 * }
 *
 * 输出c = o, 两次open同一个文件, fd1, fd2拥有自己独立的文件表，fd2读取一个字节之后，文件表中的
 * 文件位置为1, 调用dup2(fd2, fd1)之后，fd1指向fd2的文件表, 此时读取的字节便是o
 *
 */
